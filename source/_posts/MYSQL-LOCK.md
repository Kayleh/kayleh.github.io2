---
title: MYSQL MVCC & LOCK
mathjax: false
date: 2021-09-23 13:10:41
tags: [sql]
slugs: MYSQL-MVCC-LOCK
---

### MYSQL的MVCC并发控制

### 行锁

MYSQL的行锁是基于索引加载的，所以行锁要加在索引响应的行上。

##### 特征：

锁冲突概率低，并发性高，但是会有死锁的情况出现。

死锁：数据库实现了各种死锁检测和死锁超时机制。Innodb的解决方法：将持有最少行级的排他锁的事务进行回滚。

例：
```mysql
##test的主键是主键索引，uid是普通索引。
set autocommit = 0;
select * from test where uid = 1;
```
此时，uid和testId命中的这行记录就锁定了，事务未提交时其他事务修改此条记录都报错：锁定超时警告。

### 表锁

表锁就是锁定一整张表，在表锁定期间，其他事务不能对表进行操作。
表响应的是非索引字段，即`全表索引`。

##### 特征：

锁冲突概率特别高

例：
```mysql
##test的主键是主键索引，name为非索引字段。
set autocommit = 0;
select * from test where name = 1;
```


### 记录锁（行锁）

记录锁锁的是表里的某一条记录，出现条件必须是精准命中索引并且索引是唯一索引。


### 间隙锁（行锁）

间隙锁又称之为区间锁，每次锁定都是锁定一个区间，隶属行锁。
当我们查询数据用范围查询而不是相等条件查询时，查询条件命中索引，并且没有查询到符合条件的记录，此时就会将查询条件中的范围数据进行锁定(即使是范围库中不存在的数据也会被锁定)

间隙锁只会出现在可重复读的事务隔离级别中，mysql5.7默认就是可重复读。间隙锁锁的是一个区间范围，查询命中索引但是没有匹配到相关记录时，锁定的是查询的这个区间范围，上述代码中，所锁定的区间就是 (1,3]这个区间,不包含1，但是包含3，并且不包含4，也就是说这里是一个左开右闭的区间；


### 临键锁（行锁）
学习完间隙锁后我们再来看看什么是临键锁，mysql的行锁默认就是使用的临键锁，临键锁是由记录锁和间隙锁共同实现的，
间隙锁的触发条件是命中索引，范围查询没有匹配到相关记录。
而临键锁恰好相反，临键锁的触发条件也是查询条件命中索引，不过，临键锁有匹配到数据库记录；
间隙锁所锁定的区间是一个左开右闭的集合，而临键锁锁定是当前记录的区间和下一个记录的区间

数据库中只有三条数据1、5、7，当修改范围为1~8时，则锁定的区间为(1,+∞)，锁定额不单是查询范围，并且还锁定了当前范围的下一个范围区间，此时，查询的区间8，在数据库中是一个不存在的记录值，并且，如果此时的查询条件是小于或等于8，也是一样的锁定8到后面的区间。
由于7在数据库中是已知的记录，所以修改范围为1~7时，锁定后，只锁定了(1,7]，7之后的数据都没有被锁定。我们还是可以正常插入id为8的数据及其后面的数据。



###### 为什么会出现这种情况呢？为什么临键锁后匹配会这样呢？

在这里，我们不妨看看mysql的索引是怎么实现的，前面文章中有提到树结构，mysql的索引是基于B+树实现的，每个树节点上都有多个元素，即关键字数，当我们的索引树上只有1、5、7时，我们查询1~8，这个时候由于树节点关键字中并没有8，所以就把8到正无穷的区间范围都给锁定了。
那么，如果我们数据库中id有1、5、7、10，此时我们再模糊匹配id为1~8的时候，由于关键字中并没有8，所以找比8大的，也就找到了10，根据左开右闭原则，此时10也是被锁定的，但是id为11的记录还是可以正常进行插入的。这里我没有测试，感兴趣的朋友可以下去自己尝试一下。我们的锁都是基于索引的，而mysql中索引的底层是使用的B+树，我们了解了B+树的特性后，就更容易理解很多遇到锁的问题了。

